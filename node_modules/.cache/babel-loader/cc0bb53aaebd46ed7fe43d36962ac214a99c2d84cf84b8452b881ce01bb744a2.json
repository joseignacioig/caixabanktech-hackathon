{"ast":null,"code":"import { atom, epoch } from '../atom/index.js';\nimport { onMount } from '../lifecycle/index.js';\nlet computedStore = (stores, cb, batched) => {\n  if (!Array.isArray(stores)) stores = [stores];\n  let previousArgs;\n  let currentEpoch;\n  let set = () => {\n    if (currentEpoch === epoch) return;\n    currentEpoch = epoch;\n    let args = stores.map($store => $store.get());\n    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {\n      previousArgs = args;\n      let value = cb(...args);\n      if (value && value.then && value.t) {\n        value.then(asyncValue => {\n          if (previousArgs === args) {\n            // Prevent a stale set\n            $computed.set(asyncValue);\n          }\n        });\n      } else {\n        $computed.set(value);\n        currentEpoch = epoch;\n      }\n    }\n  };\n  let $computed = atom(undefined);\n  let get = $computed.get;\n  $computed.get = () => {\n    set();\n    return get();\n  };\n  let timer;\n  let run = batched ? () => {\n    clearTimeout(timer);\n    timer = setTimeout(set);\n  } : set;\n  onMount($computed, () => {\n    let unbinds = stores.map($store => $store.listen(run));\n    set();\n    return () => {\n      for (let unbind of unbinds) unbind();\n    };\n  });\n  return $computed;\n};\nexport let computed = (stores, fn) => computedStore(stores, fn);\nexport let batched = (stores, fn) => computedStore(stores, fn, true);","map":{"version":3,"names":["atom","epoch","onMount","computedStore","stores","cb","batched","Array","isArray","previousArgs","currentEpoch","set","args","map","$store","get","some","arg","i","value","then","t","asyncValue","$computed","undefined","timer","run","clearTimeout","setTimeout","unbinds","listen","unbind","computed","fn"],"sources":["/Users/joseignacio/Developer/caixabanktech-hackathon/node_modules/nanostores/computed/index.js"],"sourcesContent":["import { atom, epoch } from '../atom/index.js'\nimport { onMount } from '../lifecycle/index.js'\n\nlet computedStore = (stores, cb, batched) => {\n  if (!Array.isArray(stores)) stores = [stores]\n\n  let previousArgs\n  let currentEpoch\n  let set = () => {\n    if (currentEpoch === epoch) return\n    currentEpoch = epoch\n    let args = stores.map($store => $store.get())\n    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {\n      previousArgs = args\n      let value = cb(...args)\n      if (value && value.then && value.t) {\n        value.then(asyncValue => {\n          if (previousArgs === args) {\n            // Prevent a stale set\n            $computed.set(asyncValue)\n          }\n        })\n      } else {\n        $computed.set(value)\n        currentEpoch = epoch\n      }\n    }\n  }\n  let $computed = atom(undefined)\n  let get = $computed.get\n  $computed.get = () => {\n    set()\n    return get()\n  }\n\n  let timer\n  let run = batched\n    ? () => {\n        clearTimeout(timer)\n        timer = setTimeout(set)\n      }\n    : set\n\n  onMount($computed, () => {\n    let unbinds = stores.map($store => $store.listen(run))\n    set()\n    return () => {\n      for (let unbind of unbinds) unbind()\n    }\n  })\n\n  return $computed\n}\n\nexport let computed = (stores, fn) => computedStore(stores, fn)\nexport let batched = (stores, fn) => computedStore(stores, fn, true)\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,KAAK,QAAQ,kBAAkB;AAC9C,SAASC,OAAO,QAAQ,uBAAuB;AAE/C,IAAIC,aAAa,GAAGA,CAACC,MAAM,EAAEC,EAAE,EAAEC,OAAO,KAAK;EAC3C,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,EAAEA,MAAM,GAAG,CAACA,MAAM,CAAC;EAE7C,IAAIK,YAAY;EAChB,IAAIC,YAAY;EAChB,IAAIC,GAAG,GAAGA,CAAA,KAAM;IACd,IAAID,YAAY,KAAKT,KAAK,EAAE;IAC5BS,YAAY,GAAGT,KAAK;IACpB,IAAIW,IAAI,GAAGR,MAAM,CAACS,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACC,GAAG,CAAC,CAAC,CAAC;IAC7C,IAAI,CAACN,YAAY,IAAIG,IAAI,CAACI,IAAI,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKD,GAAG,KAAKR,YAAY,CAACS,CAAC,CAAC,CAAC,EAAE;MACnET,YAAY,GAAGG,IAAI;MACnB,IAAIO,KAAK,GAAGd,EAAE,CAAC,GAAGO,IAAI,CAAC;MACvB,IAAIO,KAAK,IAAIA,KAAK,CAACC,IAAI,IAAID,KAAK,CAACE,CAAC,EAAE;QAClCF,KAAK,CAACC,IAAI,CAACE,UAAU,IAAI;UACvB,IAAIb,YAAY,KAAKG,IAAI,EAAE;YACzB;YACAW,SAAS,CAACZ,GAAG,CAACW,UAAU,CAAC;UAC3B;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACLC,SAAS,CAACZ,GAAG,CAACQ,KAAK,CAAC;QACpBT,YAAY,GAAGT,KAAK;MACtB;IACF;EACF,CAAC;EACD,IAAIsB,SAAS,GAAGvB,IAAI,CAACwB,SAAS,CAAC;EAC/B,IAAIT,GAAG,GAAGQ,SAAS,CAACR,GAAG;EACvBQ,SAAS,CAACR,GAAG,GAAG,MAAM;IACpBJ,GAAG,CAAC,CAAC;IACL,OAAOI,GAAG,CAAC,CAAC;EACd,CAAC;EAED,IAAIU,KAAK;EACT,IAAIC,GAAG,GAAGpB,OAAO,GACb,MAAM;IACJqB,YAAY,CAACF,KAAK,CAAC;IACnBA,KAAK,GAAGG,UAAU,CAACjB,GAAG,CAAC;EACzB,CAAC,GACDA,GAAG;EAEPT,OAAO,CAACqB,SAAS,EAAE,MAAM;IACvB,IAAIM,OAAO,GAAGzB,MAAM,CAACS,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACgB,MAAM,CAACJ,GAAG,CAAC,CAAC;IACtDf,GAAG,CAAC,CAAC;IACL,OAAO,MAAM;MACX,KAAK,IAAIoB,MAAM,IAAIF,OAAO,EAAEE,MAAM,CAAC,CAAC;IACtC,CAAC;EACH,CAAC,CAAC;EAEF,OAAOR,SAAS;AAClB,CAAC;AAED,OAAO,IAAIS,QAAQ,GAAGA,CAAC5B,MAAM,EAAE6B,EAAE,KAAK9B,aAAa,CAACC,MAAM,EAAE6B,EAAE,CAAC;AAC/D,OAAO,IAAI3B,OAAO,GAAGA,CAACF,MAAM,EAAE6B,EAAE,KAAK9B,aAAa,CAACC,MAAM,EAAE6B,EAAE,EAAE,IAAI,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}