{"ast":null,"code":"import { clean } from '../clean-stores/index.js';\nlet listenerQueue = [];\nlet lqIndex = 0;\nconst QUEUE_ITEMS_PER_LISTENER = 4;\nexport let epoch = 0;\nexport let atom = initialValue => {\n  let listeners = [];\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})();\n      }\n      return $atom.value;\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener);\n      return () => {\n        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length;) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER;\n          }\n        }\n        let index = listeners.indexOf(listener);\n        if (~index) {\n          listeners.splice(index, 1);\n          if (! --$atom.lc) $atom.off();\n        }\n      };\n    },\n    notify(oldValue, changedKey) {\n      epoch++;\n      let runListenerQueue = !listenerQueue.length;\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey);\n      }\n      if (runListenerQueue) {\n        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {\n          listenerQueue[lqIndex](listenerQueue[lqIndex + 1], listenerQueue[lqIndex + 2], listenerQueue[lqIndex + 3]);\n        }\n        listenerQueue.length = 0;\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value;\n      if (oldValue !== newValue) {\n        $atom.value = newValue;\n        $atom.notify(oldValue);\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener);\n      listener($atom.value);\n      return unbind;\n    },\n    value: initialValue\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = [];\n      $atom.lc = 0;\n      $atom.off();\n    };\n  }\n  return $atom;\n};","map":{"version":3,"names":["clean","listenerQueue","lqIndex","QUEUE_ITEMS_PER_LISTENER","epoch","atom","initialValue","listeners","$atom","get","lc","listen","value","listener","push","i","length","splice","index","indexOf","off","notify","oldValue","changedKey","runListenerQueue","set","newValue","subscribe","unbind","process","env","NODE_ENV"],"sources":["/Users/joseignacio/Developer/caixabanktech-hackathon/node_modules/nanostores/atom/index.js"],"sourcesContent":["import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\nexport let atom = (initialValue) => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length;) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(\n          listener,\n          $atom.value,\n          oldValue,\n          changedKey\n        )\n      }\n\n      if (runListenerQueue) {\n        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {\n            listenerQueue[lqIndex](\n              listenerQueue[lqIndex + 1],\n              listenerQueue[lqIndex + 2],\n              listenerQueue[lqIndex + 3]\n            )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}